-------------------------------

DESCRIPTION OF PIPELINE - PART 1 ("main.sh")

To run:

./main.sh

(must be run from the root directory of the repository)

This first part of the pipeline begins with the input files (see INSTALL) and ends with
some processed gene tables with easier access to gene lengths and organisms, and
all of the BLAST results and gene neighborhoods pre-computed for easy access.

The shell script "main.sh" pipes each of the raw data
into the functions that are necessary and outputs the results of these functions 
are redirected to the appropriate output folder.

Any of the python scripts can be run individually as well - many of them are pipe commands.
Unlike the main.sh and main2.sh the individual scripts can be run from anywhere.

The steps performed are as follows: 

- Generate (annotated) amino acid and nucleotide fasta files
- Generate an annotation file for matching up later, containing organism name, gene name,
  annotation and length of each gene in tab-delimited format
- Run BLAST all vs. all

- Generate a SQLITE database containing:
   rawdata: Concatenated list of all of the raw SEED data
   organisms: A list of organisms and associated SEED features
   processed: A view containing Organism name, gene name, gene length, and annotation.
   blastresults: The blast results [concatenated], in -m9 format (ready for input into MCL)
   neighborhoods: Gene neighborhoods of each gene - neighorhood calculation allows things on either strand
      to be considered a neighborhood and looks at number of genes, not genetic distance.

-------------------------------
-------------------------------

DESCRIPTION OF PIPELINE - PART 2 ("main2.sh")

To run: ONLY AFTER running main1.sh:

./main2.sh [Inflation] [Measurement_technique] [Cutoff]

For each line of the "groups" file:
- Use the database to generate a list of blast hits for only the organisms 
- Call MCL to generate clusters
- Generate raw and flattened results files. Give each cluster run an identifier that explains what parameters
  were passed into it (parameters include inflation, measurement technique, and cutoff)

Concatinate all of the flattened results files (with unique identifiers) and import them into the
  database as the "clusters" table. Also makes a couple other tables for convenience, including "clusterorgs" which
  lists the organisms in each cluster.

-------------------------------
-------------------------------

DESCRIPTION OF PIPELINE - PART 3 ("main3.sh")

To run: ONLY after running main1.sh:

./main3.sh

For each file in the "genbank" folder:
- Parse the genbank file to get the whole-genome nucleotide sequence (which must be present)
- Create a table linking organism ID to its genome
- Import the genomes into the database

Genbank filenames must contain the organism ID for the
organism in the file (since there isn't a consistent place to look for them
within the file itself). This step is not necessary to run clustering but is
necessary to run TBLASTN or analyze intergeneic regions.

#########################
# SQL building scripts
#########################

For reference, the SQL code used to build the local sqlite database
with information from other analysis functions is located in 
builddb_1.sql (blast, neighborhoods, and raw data), builddb_2.sql (clustering), 
and builddb_3.sql (genome contigs)

##########################
# Utility functions
##########################

These don't require access to the database.
See the individual function help text for how to run them.

A list of all functions in the package can be gotten by running
db_listDbFiles.py

---> annoteSeq2Fasta.py

Convert a table containing gene IDs, annotations, and sequences to a FASTA file. 
You can specify what columns contain each of these pieces of information.

---> blastResultsToDistanceMatrix.py

Convert a BLAST results table into a distance matrix with query genes on the rows
and target genes on the columns.

---> Blast_all_v_all.py

Blast all of the fasta files in a particular folder against each other. All fasta 
files must have ".faa" or ".fasta" extension to allow distinguishing from e.g. the 
database files or other stuff in the folder.

---> catAlignments.py

Concatinate alignments by organism. The input fasta files must all contain alignments 
with the same set of organisms, only one protein per organism. The order does not 
need to be the same.

---> clusterIdToTable.py

Several functions require as an input both a run ID and a cluster ID in a table:

M_2.0_...	  1

This function is for convenience. You can pipe in a run ID and specify a list of 
cluster IDs as input arguments, and it outputs a table with the run ID duplicated 
in the first column and each separate cluster ID in the second column.

---> convertNcbiFilesToRast.py

Given a GFF, FAA, and a FFN file from NCBI's Genbank database, converts them into
the "raw" tab-delimited format needed for use with this database. Caveats:

- You must concatinate ALL of the GFF, FAA and FFN files for a given organism before
  calling this function. If you don't, the gene IDs will start over at 1 for each contig
  and you will get ID conflicts.
- Known issue: The program does not correctly deal with spliced proteins so it won't
  work for Eukaryotes or for the few self-splicing genes in the prokaryotes. The program
  will issue warnings for things it cannot match - usually it is only a few per organism
  and the user is responsible for adding them to the table.
- The user must take note of the assigned organism ID (derived from the taxID in the gff file)
  and add it to the "organisms" file.

---> convertPubseedToRast.py

Convert tab-delimited annotation file from the SEED FTP servers into the format output 
by RAST. This makes such files compatible with the rest of the database.

---> countClusters.py

Takes in an MCL cluster file and outputs the number of elements in each cluster in a 
big list. Intended to help build histograms of the number of genes in each cluster.

---> fastaToPhylip.py

Converts a fasta file into a phylip file with substituted IDs to avoid issues with the 
length of identifiers (phylip has a length limit of 10 characters on its identifiers). 
Mostly for testing purposes, and because it is nicer to look at an alignment in phylip 
format than in fasta...

---> flattenClusterFile.py

**** INTERNAL USE ****

This function is used within main2.sh to take the output from MCL clustering and turn it 
into a three-column table (run id | cluster id | gene id) to import into the database.

---> Gblocks_wrapper.py

Wrapper script to allow import of our fasta files into Gblocks without clobbering our 
existing gene identifiers and annotations. Gblocks is a tool for trimming alignment regions
of poor quality. Using the wrapper requires installing Gblocks first - it is not included
as part of this package.

---> genbank2nucleotides.py

Takes a genbank file as input and outputs the nucleotide content of the contigs in a nucleotide 
fasta file.

---> getClusterFastas.py

If you have an output file ("geneinfo file") from another function with multiple clusters in it, 
you can use this to generate a separate fasta for each of the clusters and put them all in 
one place.

---> getNeighbors_bothStrands_rast.py

Takes the raw tbl from RAST and generates a neighorhood file for each. A neighborhood file 
tells you the name of neighboring genes on the same contig, how many genes away it is, 
what contig that is, what the start location of the neighboring gene is predicted to be 
and what strand the neighboring gene is on.

This function is used to get a neighborhood file that is imported into the database.

---> locateDatabase.py

**** INTERNAL USE ****

Function call to identify the location of the sqlite database containing all the gene
and genome information in the file system. Used to make the code work independently of 
where it is called.

---> makeHistogram.py

Uses numpy to calculate bins according to the inputted parameters from a set of numbers that
is piped into it.

---> makeLeafListFromEachNode.py

Given a (rooted) Newick file, creates a file containing the child leaves of each node
in the tree. This is useful for identifying genes in common on particular branches,
looking for correlations that depend on phylogenetic geometry, etc.

---> makePresenceAbsenceFasta.py

Generates a FASTA file from an inputted table of presence/absence for each cluster. The fasta
file can be used to make a presence/absence tree with RAXML.

---> makeTabDelimitedRow.py

This is a convenience function (I use it to add organisms to the "organisms" file). Given
a list of arguments, outputs a single line separating all arguments by tabs.

E.g. 

makeTabDelimitedRow.py "Escherichia coli K12" "EcoliK12" "83333.1" >> organisms

would add an appropriately-formatted line to the organisms file for E. coli K12 with tabs
separating the organism name, abbreviation, and organism ID.

---> phylipSeqbootScript.sh

Driver script to run Seqboot from Phylip non-interactively. Useful for getting global bootstraps
from FASTTREE.

---> plotHeatmap.py

Python script to plot a heatmap given numeric data - it comes with options to include dendrograms 
or not, and to include labels or not for rows and columns, along with flexible options (as flexible
as matplotlib) for coloring. It requires a distance matrix as an input and does not pre-compute
correlations - it just plots them directly.

Example input:

1	0
0	1

Simplest usage:

plotHeatmap.py < [input]

assumes you don't want dendrograms for row or column and that no labels are present in the file.

---> plotScatter.py

(Still needs a lot of work). Uses matplotlib adn numpy to create a scatterplot from a piped input
 with two columns of numeric data.

---> pubseed2rast.py

**** INTERNAL USE ****

This is an intermediate function. Call convertPubseedToRast.sh instead.

---> raw2faa.py

**** INTERNAL USE ****

Takes the tab-delimited file from RAST and converts it to an amino-acid fasta file

---> raw2fna.py

**** INTERNAL USE ****

Takes the tab-delimted file from RAST and converts it to a nucleotide fasta file 
(only gene-encoring nucleotides end up in this fasta file).

---> raw2processed.py

**** INTERNAL USE ****

Takes the tab-delimited file from RAST and processes it to include lengths of genes
 and which organism each gene belongs to. Called as part of main1.sh.

---> RaxML_wrapper.py

A nice wrapper script for RAXML that abstracts away some of the complexity of getting 
the call correct and making sure you get the files you want out of it. 
Unlike raxml itself, takes FASTA alignments (not phylip) as input.

---> replaceGeneNamesWithAliases.py

Given a conversion table between gene names and aliases and a file in which to convert 
them, replaces all instances of each gene name with their corresponding aliases.

---> replaceOrgWithAbbrev.py

Replace organism IDs with their abbreviations (this is similar in reason to the 
replaceGeneNamesWithAliases.py - I might remove this one later).

---> sanitizeString.py

**** INTERNAL USE ****

Standard function for sanitizing strings - turns everything that isn't a letter or
a number into an underscore.

---> startDifference.py

Compute minimum difference between consecutive genes in each contig. You can use 
this to find overlapping genes...

---> tblastn_all_vs_all.py

Run tblastn in parallel for all amino acids in one folder against all the genomes 
in another folder.

---> unsanitizeGeneIds.py

Takes a sanitized gene ID (which looks like fig_\d+_\d+_peg_\d+) and turns it back
into a gene ID in the format in the database so you can match it up (looks like
fig\|\d+\.\d+\.peg\.\d+)

##########################
# Database access functions
##########################

I have written several functions to generate specific tables from the database. 
They can now be run from anywhere in the filesystem. These functions all require
you to have run ./main.sh first, and any that refer to clusters also require
./main2.sh - those that refer to genomes require you to run ./main3.sh.

Here is a description of them. See the individual function's help text for how to 
run them. Most functions expect something to be piped in and export something to 
stdout:

--> db_bidirectionalBestHits.py

    Calculates all bidirectional best hits in the database where BBH is defined 
as the a hit in which for two proteins X and Y in organisms A and B, the best hit 
to organism B from X is Y and the best hit to organism A from Y is X.

    The best hit is calcualted based on the specified scoring criteria, which can 
be E-value, maxbit, etc...

--> db_compareClusters.py

    Use this function to compare two different cluster runs. The function will tell 
you if a cluster is identical between two runs and, if not, what genes are only 
present in one cluster or the other.

--> db_displayTree.py

    Tree display function that uses the database to extract annotations for the genes
in the leaves. It has a rich set of options.
    It should (at least does in my tests) display trees with identical topology the same
way every time regardless of what is in the newick file, as long as the specified root 
and the genes on the leaves are the same.

--> db_dumpAllFasta.py

    Create a fasta file containing every protein (gene) in the database.

--> db_evaluateReactionsFromGpr.py

    Useful for looking at presence\absence results in the light of metabolic models.
Given a list of gene-protein reaction relationships (i.e. A or B) with IDs consistent
with what is in the database for a particualr organism, and a target organism you're 
interested in examining, uses the clustering results to identify whether the same 
reactions are present in the target organism or not.

    This function uses the python "eval" function and is a bit buggy.

--> db_findClustersByOrganismList.py

    Find clusters that contain ALL, NONE, or AT LEAST ONE of a specified list or organisms
for a specific clustering run. Optionally also require that the representatives be unique.

--> db_findGenesWithInternalStops.py

     I used this function to identify all of the organisms with internal STOP codons 
from RAST. You can use it to prove to yourself that the only enzymes in RAST with 
internal stop codons are the ones with pyrrolysine in them (which is encoded
by a canonical STOP codon UAG) or selenocysteine.

     Prints the genes to stdout along with their nucleic acid sequences...

--> db_getAlignemntBetweenGenes.py

    Given a list of gene IDs, generates a multiple alignment between them using the
--auto flag (which tries to automatically tune accuracy settings based on the number
and size fo sequences) in MAFFT. Outputs alignments to fasta or (optionally) phylip
format.

--> db_getAllBlastResults.py

    Gets a table with all availble blast results (useful for piping into a program to 
calculate something based on all blast results rather than a subset of them)

--> db_getAllClusterRuns.py

    Returns a list of cluster run IDs present in the database (use this function if
you don't want to distinguish other analysis by what organisms are present in the clusters)
 
--> db_getAllClustersSpecRun.py

    Get a list of all of the run id, cluster id pairs for a specified run ID

--> db_getBlastResultsBetweenSpecificGenes.py

    Pull out all of the blast results in the database in which both the query AND the target
 gene are in the specified list.

--> db_getBlastResultsBetweenSpecificOrgaisms.py

    Provide it a list of organisms (patterns) to match as input arguments. The script will 
get all of the BLAST records for organisms that match the
specified patterns against all the other organisms that match the same patterns and print them
to stdout. These results can subsequently be used for
MCL clustering by piping the results into MCL (see "db_specificOrganismClusterDriver.py" for details) and, in fact,
this is how the clustering results are generated before they are dumped into the database.

    Example usage: 

    db_getBlastResSpecificOrganisms.py "Methanosarcina"

    Prints out all of the BLAST results for any organism containing "Methanosarcina" in its name 
against any other organism with "Methanosarcina" in its name

--> db_getBlastResultsContainingGenes.py

    Unlike db_getBlastResultsBetweenSpecificGenes.py, this function returns any blast results 
where either the query OR the target gene is one of the specified genes. Use to e.g. identify 
if genes in a cluster are also highly homologous to other clusters (which could indicate an issue 
with the clustering parameters)...

--> db_getClusterGeneInformation.py

    Given a table of run ID / cluster ID pairs, generates a list of information about every gene
 in the specified clusters (from the specified runs). This information includes organism, amino
 acid sequence, nucleic acid seqeuence, and annotation.

    Generate the run ID / cluster ID pairs with for example, db_getClustersWithAnnotation, 
db_getAllClusters, etc... or generate your own if you know you're interested in a particular 
cluster (from looking at the results of one of these functions)

--> db_getClustersContainingGenes.py

    Get a list of cluster / run ID pairs containing at least one of the specified genes.

--> db_getClustersWithAnnotation.py

    Pipe in a run ID and provide annotation(s) to try to match, and this function will return any 
cluster containing at least one gene matching the desired annotations, which genes matched it, 
and the matching annotation.

    Example usage (assuming a clustering run has already been done for Methanosarcina): 

    db_getClusterRxnIds.py "Methanosarcina" | getClustersWithAnnotation.py "Phosphofructokinase"

--> db_getClustersWithNumGenes.py

    Get a list of cluster / run ID pairs containing a specified number of genes.

--> db_getClustersWithSamePAPattern.py

    Given a specified cluster / run ID pair, identifies clusters in the same run that
contain the same pattern of gene presence and absence as the query. It ignores the NUMBER
of genes present \ absent in the cluster for each organism and only checks if there is at least
one or not.

--> db_getGeneInformation.py

    Get a "gene information" table containing sequences, location, annotation, etc. for 
a particular set of genes.

--> db_getGeneNeighborhoods.py

    Get information about all genes within a specified number of genes on the genome 
from the specified genes (regardless of the size of their spacers). As of this writing 
the number of genes specified must be less than or equal to 5.

--> db_getGenesInClusters.py

    Get a list of genes present in the specified clusters (cluster/run pairs).

--> db_getGenesWithAnnotation.py

    Get a list of all genes with annotation matching the specified annotation (not 
case-sensitive and can match any part of the annotation).

--> db_getPresenceAbsenceTable_01.py

    Make a presence/absence table for every gene in the database based on all available run IDs. 

    In this particular version, the organism is given a 1 for a particular cluster if it has a 
representative in that cluster and a 0 if it does not.
7
    Note - if an organism isn't used in a particular run ID it is given a 0 for all clusters.

--> db_getPresenceAbsenceTable_pegs.py

    Make a presence/absence table for every gene in the database based on all available run IDs. 

    In this particular version, if the organism has any representatives in a particular cluster, 
the gene IDs are printed out in that cell (semicolon-delimited). If not, "NONE" is printed to the 
cell.

    Note - if an organism isn't used in a particular run ID it is given a NONE for all clusters.

--> db_listDbFiles.py

    List all of the executable files included as part of this package. Excludes the "main.sh"
functions and other setup files in the root folder.

--> db_makeArrowDiagram.py

    Given a newick file and a specified run ID, makes a diagram in which the specified
newick file is displayed next to its gene neighborhood. The gene neighborhood is colored 
according to the existence of genes in the same cluster within the specified clustering run.

--> db_makeBlastScoreTable.py

    Given a table of BLASTP results, makes a table of homology scores based on a variety 
of available metrics (minbit, maxbit, normhsp, ...). See the file for a description of 
available scores.

--> db_specificOrganismClusterDriver.py

    Specify as an input argument a tab-delimited file containing a list of organisms 
for which you want to run clustering (one group per line), for example:

    Methanosarcina
    Methanosarcina	Methanococcus
    Methanosarcina mazei	Methanosarcina barkeri

    The function automatically pulls out the BLAST results specific to the groups of
organisms specified (by calling db_getBlastResSpecificOrganisms.py) and then pipes the 
results into MCL and writes the results to a file whose name reflects the given input 
arguments.

--> db_replaceGeneNameWithAnnotation.py

    Replace a gene ID with its annotation (sanitized for input into tree viewers,
SVG parsers, and so on).

##############
# EXAMPLES
##############

Many of these can be chained together in pipelines. This describes some things I've commonly used it for.

------

Getting all clusters matching a paricular annotation across all runs.

python src/db_getAllClusterRuns.py | python src/db_getClustersWithAnnotation.py "F420" | \
python src/db_getClusterGeneInformation.py > F420_results

will gather all of the clusters for which at least one of the gene annotations contains "F420" 
(across all cluster runs), and then generates a table of information about all of the genes in those 
clusters and saves them to a file (F420_results)

-------

Getting all genes containing a particular annotation and then finding what else is in those clusters

python src/getGenesWithAnnotation.py "F420 dehydrogenase" | python src/db_getClustersContainingGenes.py | \
python src/db_getClusterGeneInformation.py

-------

Getting the gene neighborhood of all genes particular gene cluster (within a particular cluster run)

echo [runid] | python src/clusterIdToTable [clusterid] | python src/db_getGenesInCluster.py | \
python src/db_getGeneNeighborhoods.py -g 3

