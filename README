-------------------------------

DESCRIPTION OF PIPELINE - PART 1 ("main.sh")

To run:

./main.sh

(must be run from the root directory of the repository)

This first part of the pipeline begins with the input files (see INSTALL) and ends with
some processed gene tables with easier access to gene lengths and organisms, and
all of the BLAST results and gene neighborhoods pre-computed for easy access.

The shell script "main.sh" pipes each of the raw data
into the functions that are necessary and outputs the results of these functions 
are redirected to the appropriate output folder.

Any of the python scripts can be run individually as well - many of them are pipe commands.
Unlike the main.sh and main2.sh the individual scripts can be run from anywhere.

The steps performed are as follows: 

- Generate (annotated) amino acid and nucleotide fasta files
- Generate an annotation file for matching up later, containing organism name, gene name,
  annotation and length of each gene in tab-delimited format
- Run BLAST all vs. all

- Generate a SQLITE database containing:
   rawdata: Concatenated list of all of the raw SEED data
   organisms: A list of organisms and associated SEED features
   processed: A view containing Organism name, gene name, gene length, and annotation.
   blastresults: The blast results [concatenated], in -m9 format (ready for input into MCL)
   neighborhoods: Gene neighborhoods of each gene - neighorhood calculation allows things on either strand
      to be considered a neighborhood and looks at number of genes, not genetic distance.

-------------------------------
-------------------------------

DESCRIPTION OF PIPELINE - PART 2 ("main2.sh")

To run: ONLY AFTER running main1.sh:

./main2.sh [Inflation] [Measurement_technique] [Cutoff]

For each line of the "groups" file:
- Use the database to generate a list of blast hits for only the organisms 
- Call MCL to generate clusters
- Generate raw and flattened results files. Give each cluster run an identifier that explains what parameters
  were passed into it (parameters include inflation, measurement technique, and cutoff)

Concatinate all of the flattened results files (with unique identifiers) and import them into the
  database as the "clusters" table. Also makes a couple other tables for convenience, including "clusterorgs" which
  lists the organisms in each cluster.

#########################
# SQL building scripts
########################

For reference, the SQL code used to build the local sqlite database
with information from other analysis functions is located in builddb_1.sql (blast, neighborhoods, and raw data), builddb_2.sql (clustering), and builddb_3.sql (obsolete)

##########################
# Utility functions
##########################

These don't require access to the database.
See the individual function help text for how to run them.

---> addGeneIdsToGenbank.py

Utilizes the tab-delimited file from RAST to add gene IDs to the genbank file that RAST outputs to the appropriate field. 
This function will fail if the contig name is too long for NCBI standards.

---> annoteSeq2Fasta.py

Convert a table containing gene IDs, annotations, and sequences to a FASTA file. You can specify what columns contain each
 of these pieces of information.

---> Blast_all_v_all.py

Blast all of the fasta files in a particular folder against each other. All fasta files must have ".faa" or ".fasta" extension 
to allow distinguishing from e.g. the database files or other stuff in the folder.

---> catAlignments.py

Concatinate alignments by organism. The input fasta files must all contain alignments with the same set of organisms, only one
 protein per organism. The order does not need to be the same.

---> clusterIdToTable.py

Several functions require as an input both a run ID and a cluster ID in a table:

M_2.0_...	  1

This function is for convenience. You can pipe in a run ID and specify a list of cluster IDs as input arguments, and it outputs 
a table with the run ID duplicated in the first column and each separate cluster ID in the second column.

---> convertPubseedToRast.py

Convert tab-delimited annotation file from the SEED FTP servers into the format output by RAST. This makes such files compatible with the rest 
of the database.

---> countClusters.py

Takes in an MCL cluster file and outputs the number of elements in each cluster in a big list. Intended to help build histograms of the number of
 genes in each cluster.

---> fastaToPhylip.py

Converts a fasta file into a phylip file with substituted IDs to avoid issues with the length of identifiers (phylip has a length limit of 
10 characters on its identifiers). Mostly for testing purposes, and because it is nicer to look at an alignment in phylip format than in fasta...

---> flattenClusterFile.py

This function is used within main2.sh to take the output from MCL clustering and turn it into a
three-column table (run id | cluster id | gene id) to import into the database.

---> Gblocks_wrapper.py

Wrapper script to allow import of our fasta files into Gblocks without clobbering our existing gene identifiers and annotations. Gblocks is a
 tool for trimming alignment regions of poor quality.

---> genbank2nucleotides.py

Takes a genbank file as input and outputs the nucleotide content of the contigs in a nucleotide fasta file.

---> getClusterFastas.py

If you have an output file ("geneinfo file") from another function with multiple clusters in it, you can use this to generate a separate fasta for 
each of the clusters and put them all in one place.

---> getNeighbors_bothStrands_rast.py

Takes the raw tbl from RAST and generates a neighorhood file for each. A neighborhood file tells you the name of neighboring genes on the same contig, 
how many genes away it is,  what contig that is, what the start location of the neighboring gene is predicted to be and what strand the neighboring gene is on.

This function is used to get a neighborhood file that is imported into the database.

---> makeHistogram.py

Uses numpy to calculate bins according to the inputted parameters from a set of numbers that is piped into it.

---> makePresenceAbsenceFasta.py

Generates a FASTA file from an inputted table of presence/absence for each cluster. The fasta file can be used to make a presence/absence tree with RAXML.

---> plotScatter.py

(Still needs a lot of work). Uses matplotlib adn numpy to create a scatterplot from a piped input with two columns of numeric data.

---> pubseed2rast.py

This is an intermediate function. Call convertPubseedToRast instead.

---> raw2faa.py

Takes the tab-delimited file from RAST and converts it to an amino-acid fasta file

---> raw2fna.py

Takes the tab-delimted file from RAST and converts it to a nucleotide fasta file (only gene-encoring nucleotides end up in this fasta file).

---> raw2processed.py

Takes the tab-delimited file from RAST and processes it to include lengths of genes and which organism each gene belongs to.

---> RaxML_wrapper.py

A nice wrapper script for RAXML that abstracts away some of the complexity of getting the call correct and making sure you get the files you want out of it. 
Unlike raxml itself, takes FASTA alignments (not phylip) as input.

---> replaceGeneNamesWithAliases.py

Given a conversion table between gene names and aliases and a file in which to convert them, replaces all instances of each gene name with their corresponding aliases.

---> replaceOrgWithAbbrev.py

Replace organism names with their abbreviations (this is similar in reason to the replaceGeneNamesWithAliases.py - I might remove this one later).

---> splitLine.py

Split a space-delimited string into separate lines

---> startDifference.py

Compute minimum difference between consecutive genes in each contig. You can use this to find overlapping genes...

---> tblastn_all_vs_all.py

Run tblastn in parallel for all amino acids in one folder against all the genomes in another folder.


##########################
# Database access functions
##########################

I have written several functions to generate specific tables from the database. They can now be run from anywhere
in the filesystem.

Here is a description of them. See the individual function's help text for how to run them. Most functions expect something to be piped in and export something to stdout:

--> db_bidirectionalBestHits.py

    Calculates all bidirectional best hits in the database where BBH is defined as the a hit in which for two proteins X and Y in 
    organisms A and B, the best hit to organism B from X is Y and the best hit to organism A from Y is X.

    The best hit is calcualted based on the specified scoring criteria, which can be E-value, maxbit, etc...

--> db_compareClusters.py

    Use this function to compare two different cluster runs. The function will tell you if a cluster is identical between two runs and, 
    if not, what genes are only present in one cluster or the other.

--> db_displayTree.py

    Tree display function that uses the database to extract annotations for the genes in the leaves. It has a rich set of options.
    It should (at least does in my tests) display trees with identical topology the same way every time regardless of what is in the nexus file,
    as long as the specified root and the genes on the leaves are the same.

--> db_findGenesWithInternalStops.py

     I used this function to identify all of the organisms with internal STOP codons from RAST. You can use it to prove
     to yourself that the only enzymes in RAST with internal stop codons are the ones with pyrrolysine in them (which is encoded
     by a canonical STOP codon UAG)

     Usage: python src/db_findgenesWithInternalStops.py

     Prints the genes to stdout along with the nucleic acid sequences...

--> db_getAllBlastResults.py

    Gets a table with all blast results (useful for piping into a program to calculate something based on all blast results rather than a subset of them)

--> db_getAllClusterRuns.py

    Returns a list of cluster run IDs present in the database (use this function if you don't want to distinguish other analysis
    by what organisms are present in the clusters)
 
--> db_getAllClustersSpecRun.py

    Get a list of all of the run id, cluster id pairs for a specified run ID

--> db_getBlastResultsBetweenSpecificGenes.py

    Pull out all of the blast results in the database in which both the query AND the target gene are in the specified list.

--> db_getBlastResultsBetweenSpecificOrgaisms.py

    Provide it a list of organisms (patterns) to match as input arguments. The script will 
    get all of the BLAST records for organisms that match the
    specified patterns against all the other organisms that match the same patterns and print them
    to stdout. These results can subsequently be used for
    MCL clustering by piping the results into MCL (see "db_specificOrganismClusterDriver.py" for details) and, in fact,
    this is how the clustering results are generated before they are dumped into the database.

    Example usage: 

    python src/db_getBlastResSpecificOrganisms.py "Methanosarcina"

    Prints out all of the BLAST results for any organism containing "Methanosarcina" in its name against any other organism
    with "Methanosarcina" in its name

    You can call this with more than one name, for example:

    python src/db_getBlastResSpecificOrganisms.py "acetivorans" "barkeri"

    will get all BLAST hits of acetivorans strains vs. barkeri strains (and each of those against themselves as well)

--> db_getBlastResultsContainingGenes.py

    Unlike db_getBlastResultsBetweenSpecificGenes.py, this function returns any blast results where either the query OR the target gene is one of 
    the specified genes. Use to e.g. identify if genes in a cluster are also highly homologous to other clusters (which could indicate an issue with
    the clustering parameters)...

--> db_getClusterGeneInformation.py

    Given a table of run ID / cluster ID pairs, generates a list of information about every gene in the specified clusters
    (from the specified runs). This information includes organism, amino acid sequence, nucleic acid seqeuence, and annotation.

    Generate the run ID / cluster ID pairs with for example, db_getClustersWithAnnotation, db_getAllClusters, etc...
    or generate your own if you know you're interested in a particular cluster (from looking at the results of one of these functions)

--> db_getClusterRunIds.py

    Provide this function with a list of organisms (patterns) to match as input arguments. It will generate for you a list of all the clustering runs
    in the database which were done using exactly the organisms from the specified patterns.

    Example: python src/db_getClusterRunIds.py "Methanosarcina"

    returns an error if you have not run any clustering analysis on the Methanosarcina against each other, but
    returns the run ID (s) of any runs in which you have run Methanosarcina against each other to stdout (which can be piped into other commands)

    This command should be called with the same patterns that you provided in the "groups" file for best results (i.e. the same ones used to call
    db_specificOrganismClusterDriver.py)

--> db_getClustersContainingGenes.py

    Get a list of cluster / run ID pairs containing at least one of the specified genes.

--> db_getClustersWithAnnotation.py

    Pipe in a run ID and provide annotation(s) to try to match, and this function will return any cluster containing at least one gene
    matching the desired annotations, which genes matched it, and the matching annotation.

    Example usage (assuming a clustering run has already been done for Methanosarcina): 

    python src/db_getClusterRxnIds.py "Methanosarcina" | python src/getClustersWithAnnotation.py

--> db_getClustersWithNumGenes.py

    Get a list of cluster / run ID pairs containing a specified number of genes.

--> db_getCoreGeneClusters.py

    Pipe in a run ID and it will return all of the clusters containing exactly one copy of the gene for each organism that was used
    to generate that run.

    This function only returns the run ID, cluster Id, gene ID and annotation. If you want more information than this, pipe the results of this into
    db_getClusterGeneInformation.py

--> db_getGeneInformation.py

    Get a "gene information" table containing sequences, location, annotation, etc. for a particular set of genes.

--> db_getGeneNeighborhoods.py

    Get information about all genes within a specified number of genes on the genome from the specified genes (regardless of the size of their spacers).
     As of this writing the number of genes specified must be less than or equal to 5.

--> db_getGenesInClusters.py

    Get a list of genes present in the specified clusters (cluster/run pairs).

--> db_getGenesWithAnnotation.py

    Get a list of all genes with annotation matching the specified annotation (not case-sensitive and can match any part of the annotation).

--> db_getPresenceAbsenceTable_01.py

    Make a presence/absence table for every gene in the database based on all available run IDs. 

    In this particular version, the organism is given a 1 for a particular cluster if it has a representative in that cluster and a 0 if it does not.

    Note - if an organism isn't used in a particular run ID it is given a 0 for all clusters.

--> db_getPresenceAbsenceTable_pegs.py

    Make a presence/absence table for every gene in the database based on all available run IDs. 

    In this particular version, if the organism has any representatives in a particular cluster, the gene IDs are printed out in that cell 
    (semicolon-delimited). If not, "NONE" is printed to the cell.

    Note - if an organism isn't used in a particular run ID it is given a NONE for all clusters.

--> db_makeArrowDiagram.py

    Given a newick file and a specified run ID, makes a diagram in which the specified newick file is displayed next to its gene neighborhood. 
    The gene neighborhood is colored according to the existence of genes in the same cluster within the specified clustering run.

--> db_makeBlastScoreTable.py

    Given a table of BLASTP results, makes a table of homology scores based on a variety of available metrics (minbit, maxbit, normhsp, ...). See the file for a description of available scores.

--> db_specificOrganismClusterDriver.py

    Specify as an input argument a tab-delimited file containing a list of organisms for which you want to run clustering (one group per line), for example:

    Methanosarcina
    Methanosarcina	Methanococcus
    Methanosarcina mazei	Methanosarcina barkeri

    The function automatically pulls out the BLAST results specific to the groups of organisms specified (by calling db_getBlastResSpecificOrganisms.py)
    and then pipes the results into MCL and writes the results to a file whose name reflects the given input arguments.

##############
# EXAMPLES
##############

Many of these can be chained together in pipelines. This describes some things I've commonly used it for.

------

Getting all clusters matching a paricular annotation across all runs.

python src/db_getAllClusterRuns.py | python src/db_getClustersWithAnnotation.py "F420" | python src/db_getClusterGeneInformation.py > F420_results

will gather all of the clusters for which at least one of the gene annotations contains "F420" (across all cluster runs), and then
generates a table of information about all of the genes in those clusters and saves them to a file (F420_results)

-------

Getting all genes containing a particular annotation and then finding what else is in those clusters

python src/getGenesWithAnnotation.py "F420 dehydrogenase" | python src/db_getClustersContainingGenes.py | python src/db_getClusterGeneInformation.py

-------

Getting the gene neighborhood of all genes particular gene cluster (within a particular cluster run)

echo [runid] | python src/clusterIdToTable [clusterid] | python src/db_getGenesInCluster.py | python src/db_getGeneNeighborhoods.py -g 3

